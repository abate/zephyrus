
open Resource_types_t
open Resource_types_j

open Helpers

type port_name = Resource_types_t.port_name

(** Printing functions for the basic types *)
(** (We could use those generated by ATD, but they automatically
    add quotes around everything and it looks pretty bad.) *)
let string_of_port_name           port_name           = port_name
let string_of_resource_type_name  resource_type_name  = resource_type_name
let string_of_state_name          state_name          = state_name

(* Type port_relation_type *)
type port_relation_type = Provides | Requires

let string_of_port_relation_type port_relation_type =
  match port_relation_type with
  | Provides -> "Provides" 
  | Requires -> "Requires"


(* Type domain_element *)
type domain_element = (Resource_types_t.resource_type_name * Resource_types_t.state_name)

let string_of_domain_element domain_element =
  let (resource_type_name, state_name) = domain_element
  in
  Printf.sprintf 
    "(%s, %s)"
    (string_of_resource_type_name resource_type_name)
    (string_of_state_name         state_name)


(* Type typing_context *)
type t = {
  typing_context_domain : domain_element list;
  typing_context_ports  : port_name list;
  typing_context_delta  : domain_element -> port_name -> port_relation_type -> port_quantity;
  typing_context_gamma  : domain_element -> port_name list;
}

(* Accessing *)
let domain typing_context = typing_context.typing_context_domain
and ports  typing_context = typing_context.typing_context_ports
and delta  typing_context = typing_context.typing_context_delta
and gamma  typing_context = typing_context.typing_context_gamma

(* Creating *)
let create_ports resource_types =
  BatList.unique ( 
    List.flatten ( 
      List.map ( fun resource_type -> 
        let typePorts = 
          List.map ( fun state ->
            
            let statePorts = 
              ( 
                List.map 
                  (fun (port_name, port_quantity) -> port_name) 
                  (state.state_require_ports @ state.state_provide_ports) 
              )
              @ state.state_conflict_ports
            in
            statePorts

          ) resource_type.resource_type_states
        in
        List.flatten typePorts
    ) resource_types 
    ) 
  )

let create_domain resource_types =
  List.flatten (
    List.map ( fun resource_type ->
      List.map ( fun state ->

        (resource_type.resource_type_name, state.state_name)

      ) resource_type.resource_type_states
    ) resource_types
  )

let string_of_single_delta domain_element port_name port_relation_type =
  Printf.sprintf 
    "delta(%s, %s, %s)"
    (string_of_domain_element domain_element)
    (string_of_port_name port_name)
    (string_of_port_relation_type port_relation_type)

let create_delta resource_types =
  fun domain_element port_name port_relation_type ->
    let (resource_type_name, state_name) = domain_element in
    try
      let resource_type = 
        List.find ( fun resource_type -> resource_type.resource_type_name = resource_type_name ) resource_types
      in
      let state = 
        List.find ( fun state -> state.state_name = state_name ) resource_type.resource_type_states
      in
      let ports = 
        match port_relation_type with
        | Provides -> state.state_provide_ports
        | Requires -> state.state_require_ports
      in
      try
        let port_quantity = List.assoc port_name ports
        in
        port_quantity
      with Not_found -> 0
    with
    | Not_found ->
        failwith (Printf.sprintf 
         "delta invocated on wrong arguments!\n%s"
         (string_of_single_delta domain_element port_name port_relation_type) )


let string_of_single_gamma domain_element =
  Printf.sprintf 
    "gamma(%s)"
    (string_of_domain_element domain_element)

let create_gamma resource_types =
  fun domain_element ->
    let (resource_type_name, state_name) = domain_element in
    try
      let resource_type = 
        List.find ( fun resource_type -> resource_type.resource_type_name = resource_type_name ) resource_types
      in
      let state = 
        List.find ( fun state -> state.state_name = state_name ) resource_type.resource_type_states
      in
      state.state_conflict_ports
    with
    | Not_found ->
        failwith (Printf.sprintf 
         "gamma invocated on wrong arguments!\n%s"
         (string_of_single_gamma domain_element) )


let create_typing_context resource_types = {
  typing_context_domain = create_domain resource_types;
  typing_context_ports  = create_ports  resource_types;
  typing_context_delta  = create_delta  resource_types;
  typing_context_gamma  = create_gamma  resource_types;
}

(* Printing *)

let string_of_domain typing_context =
  let domain = domain typing_context in
  let strings = List.map string_of_domain_element domain
  in
  Printf.sprintf
    "Domain:\n%s\n"
    (lines_of_strings strings)

let string_of_ports typing_context =
  let ports = ports typing_context in
  let strings = List.map string_of_port_name ports
  in
  Printf.sprintf
    "Ports:\n%s\n"
    (String.concat ", " strings)

let string_of_delta typing_context port_relation_type =
  let domain = domain typing_context
  and ports  = ports typing_context
  and delta  = delta typing_context
  in 
  let strings = 
    List.map ( 
      fun port_name -> 
        let strings =
          List.map (
            fun domain_element ->

              Printf.sprintf 
                "%s = %d"
                (string_of_single_delta domain_element port_name port_relation_type)
                (delta                  domain_element port_name port_relation_type)

          ) domain
        in
        lines_of_strings strings
    ) ports
  in
  Printf.sprintf 
    "Delta [%s]:\n%s\n" 
    (string_of_port_relation_type port_relation_type)
    (lines_of_strings strings)

let string_of_gamma typing_context =
  let domain = domain typing_context
  and gamma  = gamma  typing_context
  in 
  let strings = 
    List.map ( 
      fun domain_element -> 
        let conflict_ports        = List.map string_of_port_name (gamma domain_element) in
        let conflict_ports_string = String.concat ", " conflict_ports in

          Printf.sprintf
            "%s = {%s}"
            (string_of_single_gamma domain_element)
            conflict_ports_string    
          
    ) domain
  in
  Printf.sprintf
    "Gamma:\n%s\n"
    (lines_of_strings strings)




let requires_or_provides 
  (port_relation_type : port_relation_type) 
  (typing_context : t) 
  (domain_element : domain_element) 
  : (port_name * int) list =

  BatList.filter_map (fun port_name -> 
      let delta_value =
        (delta typing_context) domain_element port_name port_relation_type
      in
      if delta_value > 0
      then Some (port_name, delta_value)
      else None
  ) (ports typing_context)

let requires = requires_or_provides Requires
and provides = requires_or_provides Provides  


(* Functions for Max-Rest constraints *)

let r typing_context port_name =
  let all_require_values_for_the_port =
    BatList.sort (BatList.unique (
      List.map
      (fun domain_element -> (delta typing_context) domain_element port_name Requires )
      (domain typing_context)
    ) )
  in
  match all_require_values_for_the_port with
  | [r] -> Some r
  | [0; r] -> Some r
  | [0; 1; r] -> Some r
  | _ -> None


let max_provide typing_context port_name =
  BatList.max (
    List.map
    (fun domain_element -> (delta typing_context) domain_element port_name Provides )
    (domain typing_context) )


let string_of_r typing_context =
  let ports = ports typing_context in
  let rs = List.map (r typing_context) ports
  in
  let strings =
    List.map2 
    (fun port_name r ->
      Printf.sprintf "r(%s) = %s"
      (string_of_port_name port_name)
      (match r with Some r -> string_of_int r | None -> "none!") )
    ports rs
  in
  Printf.sprintf
    "R:\n%s\n"
    (lines_of_strings strings)


let string_of_max_provide typing_context =
  let ports = ports typing_context in
  let max_provides = List.map (max_provide typing_context) ports
  in
  let strings =
    List.map2 
    (fun port_name max_provide ->
      Printf.sprintf "max_provide(%s) = %d"
      (string_of_port_name port_name)
      max_provide
    ) ports max_provides
  in
  Printf.sprintf
    "Max_provide:\n%s\n"
    (lines_of_strings strings)